# zmalloc

zmalloc은 표준 malloc을 래핑해 다음을 제공합니다:

1. 메모리 사용량 추적: 총 할당 메모리 계산
2. 크로스 플랫폼 지원: jemalloc, tcmalloc, libc 등
3. 스레드 안전: 멀티스레드 환경에서 안전한 추적


## 전역 메모리 카운터

- 핵심: Redis는 인메모리 데이터베이스
- Redis는 모든 데이터를 메모리에 저장합니다. 메모리 사용량을 추적하지 않으면:
  - 메모리 부족 시 시스템이 OOM으로 종료될 수 있음
  - 메모리 제한을 설정할 수 없음
  - 메모리 사용량을 모니터링할 수 없음

1. maxmemory 제한 관리
2. Eviction 정책 실행
3. 메모리 모니터링
4. 시스템 안정성

## 캐시 패딩 (Cache Padding)

- 문제: 작은 변수가 같은 캐시 라인에 모여 False Sharing 발생
- 해결: 패딩으로 각 구조체를 64바이트로 맞춰 독립적인 캐시 라인 배치
- 효과: 멀티스레드 환경에서 성능 향상

~~~
typedef struct {
    long long counter;  // 8바이트
    char padding[56];   // 56바이트 빈 공간
} entry;  // 총 64바이트
~~~

### 캐시 라인과 메모리 주소의 관계

~~~
캐시 라인 번호 = 메모리 주소 ÷ 64

예:
  0x1000 ÷ 64 = 64번 캐시 라인
  0x1001 ÷ 64 = 64번 캐시 라인 (같음!)
  0x1002 ÷ 64 = 64번 캐시 라인 (같음!)
  ...
  0x103F ÷ 64 = 64번 캐시 라인 (같음!)
  
  0x1040 ÷ 64 = 65번 캐시 라인 (다름!)
  0x1041 ÷ 64 = 65번 캐시 라인 (같음!)
  ...
  
메모리 주소:     캐시 라인:
0x1000 ────────→ 캐시 라인 64
0x1001 ────────→ 캐시 라인 64 (같음)
0x1002 ────────→ 캐시 라인 64 (같음)
...
0x103F ────────→ 캐시 라인 64 (같음)

0x1040 ────────→ 캐시 라인 65 (다름!)
0x1041 ────────→ 캐시 라인 65 (같음)
...
0x107F ────────→ 캐시 라인 65 (같음)

→ 0x1000~0x103F는 모두 같은 캐시 라인  
~~~

### False Sharing 문제

~~~
// Thread 1은 counter1만 사용
// Thread 2는 counter2만 사용

int counter1;  // 주소: 0x1000
int counter2;  // 주소: 0x1004

// 둘 다 같은 캐시 라인 64번에 위치!
~~~
Thread 1: counter1만 수정
Thread 2: counter2만 읽기

→ 서로 다른 변수인데
→ 같은 캐시 라인에 있어서
→ Thread 1이 수정하면 Thread 2의 캐시가 무효화됨
→ Thread 2는 아무것도 안 했는데 느려짐!

→ 이것이 False Sharing!


